open #lib/sum;

let NatF R = Maybe R;
let NatIF (R : () -> Type) (_ : ()) : Type = NatF (R []);

let Nat = Fix NatIF [];
let Z : Nat = Roll {F = NatIF} Nothing;
let S (n : Nat) : Nat = Roll {F = NatIF} (Just n);

let elimNat (P : Nat -> Type) (z : P Z) (s : (n : Nat) -> P n -> P (S n)) (n : Nat) : P n
  = elimFix {F = NatIF} P (\ind x. elimSum (\s. P (Roll {F = NatIF} s)) (\_. z) (\m. s m (ind m)) x) n;
let recNat {R} (n : Nat) (z : R) (s : Nat -> R -> R) : R = elimNat (\_. R) z s n;
let foldNat {R} (n : Nat) (z : R) (s : R -> R) : R = elimNat (\_. R) z (\_. s) n;
let caseNat {R} (n : Nat) (z : R) (s : Nat -> R) : R = recNat n z (\m _. s m);

let pred n = caseNat n Z (\m. m);
let (+) a b = foldNat a b S;
let (*) a b = foldNat a Z ((+) b);

export (Nat, Z, S, elimNat, recNat, foldNat, caseNat, pred, (+), (*))
