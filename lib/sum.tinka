open #lib/enum (switch, case);

mod {
  Sum <l k> (A : Type l) (B : Type k) : Type (max l k) =
    (tag : '[Left, Right]) **
    (value : case tag [Lift <max l k> A, Lift <max l k> B]) **
    ();

  Left <l k> {A : Type l} {B : Type k} (x : A) : Sum A B = ['Left, x];
  Right <l k> {A : Type l} {B : Type k} (x : B) : Sum A B = ['Right, x];

  elimSum <r l k> {A : Type l} {B : Type k}
    (P : Sum A B -> Type r)
    (left : (x : A) -> P (Left <l> <k> x))
    (right : (x : B) -> P (Right <l> <k> x))
    (x : Sum A B) : P x
    = (switch x.tag (\tag. (value : case tag [Lift <max l k> A, Lift <max l k> B]) -> P [tag, value])
        [left, right]) x.value;

  caseSum <l k r> {A : Type l} {B : Type k} {R : Type r} (x : Sum A B) (left : A -> R) (right : B -> R) : R
    = elimSum (\_. R) left right x;

  sum <l k r> {A : Type l} {B : Type k} {R : Type r} (left : A -> R) (right : B -> R) (x : Sum A B) : R
    = caseSum <l> <k> <r> x left right;

  Maybe <l> (A : Type l) = Sum () A;

  Just <l> {A : Type l} (x : A) : Maybe A = Right <0> x;
  Nothing <l> {A : Type l} : Maybe A = Left [];
}
