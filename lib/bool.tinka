open #lib/enum (case);
open #lib/void (Void, elimVoid);
open #lib/id;

mod {
  Bool = '[True, False];
  True : Bool = 'True;
  False : Bool = 'False;

  private elimBoolFalse <k> (P : '[False] -> Type k) (f : P 'False) (x : '[False]) : P x =
    case x P f (elimVoid (\y. P (TS y)));
  elimBool <k> (P : Bool -> Type k) (t : P True) (f : P False) (b : Bool) : P b
    = case b P t (elimBoolFalse (\y. P (TS y)) f);

  if_ <l> {A : Type l} (b : Bool) (t : A) (f : A) : A = elimBool (\_. A) t f b;
  if-ind_ <l> (P : Bool -> Type l) (b : Bool) (t : P True) (f : P False) : P b = elimBool P t f b;

  not b = if b then False else True;
  (!) = not;
  (&&) a b = if a then b else False;
  (||) a b = if a then True else b;

  liftBool b = if b then () else Void;
  trueNotFalse : True !~ False = \p. rewrite liftBool p [];

  notnotId {b : Bool} : not (not b) ~ b =
    if b : \b. not (not b) ~ b then Refl else Refl;
}
