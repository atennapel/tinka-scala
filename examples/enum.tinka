def if {A} (b : Bool) (t f : A) : A = elimBool (\_. A) t f b;
def Sum (A B : Type) : Type = (tag : Bool) ** if tag A B;
def Left {A B} (x : A) : Sum A B = (True, x);
def Right {A B} (x : B) : Sum A B = (False, x);
def elimSum
  {A B}
  (P : Sum A B -> Type)
  (left : (x : A) -> P (Left x))
  (right : (x : B) -> P (Right x))
  (x : Sum A B) : P x
  = elimBool (\tag. (x : if tag A B) -> P (tag, x)) left right x.tag x._2;
def caseSum {A B R} (x : Sum A B) (left : A -> R) (right : B -> R) : R =
  elimSum (\_. R) left right x;

def Fix (F : Type -> Type) : Type = IFix {()} (\f _. F (f [])) [];
def In {F : Type -> Type} (x : F (Fix F)) : Fix F = IIn {()} {\f _. F (f [])} {[]} x;
def elimFix
  {F : Type -> Type}
  (P : Fix F -> Type)
  (alg : ((z : Fix F) -> P z) -> (y : F (Fix F)) -> P (In {F} y))
  (x : Fix F) : P x
  = elimIFix {()} {\f _. F (f [])} P (\rec y. alg rec y) x;

def ListF A R = Sum ((head : A) (tail : R) ** ()) ();
def List A = Fix (ListF A);
def Nil {A} : List A = In {ListF A} (Right []);
def Cons {A} (head : A) (tail : List A) : List A = In {ListF A} (Left [head, tail]);
def elimList
  {A}
  (P : List A -> Type)
  (nil : P Nil)
  (cons : (head : A) (tail : List A) -> P tail -> P (Cons head tail))
  (x : List A) : P x
  = elimFix {ListF A} P (\rec y. elimSum (\s. P (In {ListF A} s))
      (\data. cons data.head data.tail (rec data.tail)) (\_. nil) y) x;
def foldr {A R} (nil : R) (cons : A -> R -> R) (list : List A) : R
  = elimList (\_. R) nil (\hd _ tl. cons hd tl) list;
def map {A B} (fn : A -> B) (list : List A) : List B
  = foldr Nil (\hd tl. Cons (fn hd) tl) list;

def Enum = List Label;

{-
data Tag : Enum -> Type where
  TZ : {l : Label} {e : Enum} -> Tag (Cons l e)
  TS : {l : Label} {e : Enum} -> Tag e -> Tag (Cons l e)
-}
def TagF (R : Enum -> Type) (e : Enum) : Type
  = Sum
      ((label : Label) (enum : Enum) (rest : R enum) (proof : Id (Cons label enum) e) ** ())
      ((label : Label) (enum : Enum) (proof : Id (Cons label enum) e) ** ());
def Tag : Enum -> Type = IFix TagF;
def TZ {l : Label} {e : Enum} : Tag (Cons l e) =
  IIn {F = TagF} {Cons l e} (Right
    {(label : Label) (enum : Enum) (rest : Tag enum) (proof : Id (Cons label enum) (Cons l e)) ** ()}
    {(label : Label) (enum : Enum) (proof : Id (Cons label enum) (Cons l e)) ** ()}
    [l, e, Refl]);
def TS {l : Label} {e : Enum} (rest : Tag e) : Tag (Cons l e) =
  IIn {F = TagF} {Cons l e} (Left
    {(label : Label) (enum : Enum) (rest : Tag enum) (proof : Id (Cons label enum) (Cons l e)) ** ()}
    {(label : Label) (enum : Enum) (proof : Id (Cons label enum) (Cons l e)) ** ()}
    [l, e, rest, Refl]);
def elimTag
  (P : {e} -> Tag e -> Type)
  (tz : {l : Label} {e : Enum} -> P {Cons l e} TZ)
  (ts : {l : Label} {e : Enum} (t : Tag e) -> P t -> P {Cons l e} (TS t))
  {e} (x : Tag e) : P x
  = elimIFix {F = TagF} P (\rec {e'} y. elimSum (\s. P (IIn {F = TagF} {e'} s))
      (\data.
        elimId (\{y} e. P (IIn {F = TagF} {y}
          (Left
            {(label : Label) (enum : Enum) (rest : Tag enum) (proof : Id (Cons label enum) y) ** ()}
            {(label : Label) (enum : Enum) (proof : Id (Cons label enum) y) ** ()}
            [data.label, data.enum, data.rest, e])))
          (ts {data.label} {data.enum} data.rest (rec data.rest)) data.proof)
      (\data.
        elimId (\{y} e. P (IIn {F = TagF} {y}
          (Right
            {(label : Label) (enum : Enum) (rest : Tag enum) (proof : Id (Cons label enum) y) ** ()}
            {(label : Label) (enum : Enum) (proof : Id (Cons label enum) y) ** ()}
            [data.label, data.enum, e])))
          (tz {data.label} {data.enum}) data.proof)
      y) x;

def TaggedData = List (Label ** Type);
def TaggedDataEnum (d : TaggedData) : Enum = foldr {Label ** Type} Nil (\x r. Cons x._1 r) d;
def TaggedDataTypes (d : TaggedData) : List Type = foldr {Label ** Type} Nil (\x r. Cons x._2 r) d;

def Sing {A} (v : A) = (value : A) (proof : Id value v) ** ();
def MkSing {A} (v : A) : Sing v = [v, Refl];
