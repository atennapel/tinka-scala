-- booleans
let Bool = (A : Type) -> A -> A -> A;
let True : Bool = \A t f. t;
let False : Bool = \A t f. f;

let if (A : Type) (b : Bool) (t : A) (f : A) : A = b A t f;

let not (b : Bool) : Bool = if Bool b False True;
let (&&) (a b : Bool) : Bool = if Bool a b False;
let (||) (a b : Bool) : Bool = if Bool a True b;

-- natural numbers
let Nat = (A : Type) -> A -> (A -> A) -> A;
let Z : Nat = \A z s. z;
let S (n : Nat) : Nat = \A z s. s (n A z s);

let foldNat (A : Type) (n : Nat) (z : A) (s : A -> A) : A = n A z s;

let isZero (n : Nat) : Bool = foldNat Bool n True (\_. False);

let (+) (a b : Nat) : Nat = foldNat Nat a b S;
let (*) (a b : Nat) : Nat = foldNat Nat a Z ((+) b);

-- identity type
let Id (A : Type) (x y : A) = (F : A -> Type) -> F x -> F y;
let Refl (A : Type) (x : A) : Id A x x = \F y. y;

let add11eq2 : Id Nat (1 + 1) 2 = Refl Nat 2;
let mul22eq4 : Id Nat (2 * 2) 4 = Refl Nat 4;

mul22eq4
