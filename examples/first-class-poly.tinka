-- taken from https://github.com/AndrasKovacs/elaboration-zoo/blob/master/06-first-class-poly/examples.txt
let List A = (R : Type) -> R -> (A -> R -> R) -> R;
let nil : {A} -> List A = \_ n c. n;
let cons : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let single : {A} -> A -> List A = \a. cons a nil;
let Id A = (I : Type) -> (A -> I) -> I;
let mkId : {A} -> A -> Id A = \a I f. f a;
let unId : {A} -> Id A -> A = \i. i _ (\x. x);
let Bool = (B : Type) -> B -> B -> B;
let true : Bool = \_ t f. t;
let Pair A B = (P : Type) -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B = \a b P p. p a b;
let Nat = (N : Type) -> (N -> N) -> N -> N;
let zero : Nat = \_ s z. z;
let suc : Nat -> Nat = \n A s z. s (n A s z);
let append : {A} -> List A -> List A -> List A = \xs ys L n c. xs L (ys L n c) c;
let map : {A B} -> (A -> B) -> List A -> List B = \f as L n c. as L n (\a. c (f a));
let length : {A} -> List A -> Nat = \as N s z. as N z (\x. s);
let IdTy = {A} -> A -> A;
let id : {A} -> A -> A = \x. x;
let ids : List IdTy = nil;
let oneId : Id IdTy = mkId id;
let const : {A B} -> A -> B -> A = \x y. x;
let choose : {A} -> A -> A -> A = const;
let poly : IdTy -> Pair Nat Bool = \f. pair (f zero) (f true);
let auto : IdTy -> IdTy = id;
let auto2 : {B} -> IdTy -> B -> B = \_ b. b;
let app : {A B} -> (A -> B) -> A -> B = id;
let revapp : {A B} -> A -> (A -> B) -> B = \x f. f x;
let ST S A = S -> A;
let runST : {A} -> ({S} -> ST S A) -> A = \f. f {Bool} true;
let argST : {S} -> ST S Nat = \_. zero;

let A2 : IdTy -> IdTy = choose id;
let A3 = choose nil ids;
let A4 : IdTy -> IdTy = \(x : IdTy). x x;
let A5 = id auto;
let A6 : {B} -> IdTy -> B -> B = id auto2;
let A7 = choose id auto;
let A9 : ({A} -> (A -> A) -> List A -> A) -> IdTy
  = \f. f (choose id) ids;
let A10 = poly id;
let A11 = poly (\x. x);
let A12 = id poly (\x. x);

let C1 = length ids;
let C2 = id ids;
let C3 : IdTy = unId oneId;
let C4 : List IdTy = single id;
let C5 = cons id ids;
let C6 = cons (\x. x) ids;
let C7 = append (single suc) (single id);
let C8 : _ -> IdTy = \(g : {A} -> List A -> List A -> A). g (single id) ids;
let C9 = map poly (single id);
let C10 = map unId (single oneId);

let D1 = app poly id;
let D2 = revapp id poly;
let D3 = runST argST;
let D4 = app runST argST;
let D5 = revapp argST runST;

let E3 = \(r : ({A} -> A -> ({B} -> B -> B) -> Nat)). r (\x y. y);

let E2 =
  \(h : Nat -> ({A} -> A -> A)) (k : {A} -> A -> List A -> A) (lst : List ({A} -> Nat -> A -> A)).
    k (\x. h x) lst;

[]
