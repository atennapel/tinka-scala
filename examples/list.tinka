-- prelude
def if {A} (b : Bool) (t f : A) : A = elimBool (\_. A) t f b;
def Sum (A B : Type) : Type = (tag : Bool) ** if tag A B;
def Left {A B} (x : A) : Sum A B = (True, x);
def Right {A B} (x : B) : Sum A B = (False, x);
def elimSum
  {A B}
  (P : Sum A B -> Type)
  (left : (x : A) -> P (Left x))
  (right : (x : B) -> P (Right x))
  (x : Sum A B) : P x
  = elimBool (\tag. (x : if tag A B) -> P (tag, x)) left right (x.tag) (x._2);
def caseSum {A B R} (x : Sum A B) (left : A -> R) (right : B -> R) : R =
  elimSum (\_. R) left right x;

def Fix (F : Type -> Type) : Type = IFix {()} (\f _. F (f [])) [];
def In {F : Type -> Type} (x : F (Fix F)) : Fix F = IIn {()} {\f _. F (f [])} {[]} x;
def elimFix
  {F : Type -> Type}
  (P : Fix F -> Type)
  (alg : ((z : Fix F) -> P z) -> (y : F (Fix F)) -> P (In {F} y))
  (x : Fix F) : P x
  = elimIFix {()} {\f _. F (f [])} P (\rec y. alg rec y) x;

{-
data List A where
  Nil : List A
  Cons : A -> List A -> List A
-}
def ListF A R = Sum ((head : A) (tail : R) ** ()) ();
def List A = Fix (ListF A);
def Nil {A} : List A = In {ListF A} (Right []);
def Cons {A} (head : A) (tail : List A) : List A = In {ListF A} (Left [head, tail]);
def elimList
  {A}
  (P : List A -> Type)
  (nil : P Nil)
  (cons : (head : A) (tail : List A) -> P tail -> P (Cons head tail))
  (x : List A) : P x
  = elimFix {ListF A} P (\rec y. elimSum (\s. P (In {ListF A} s))
      (\data. cons (data.head) (data.tail) (rec (data.tail))) (\_. nil) y) x;

def foldr {A R} (nil : R) (cons : A -> R -> R) (list : List A) : R
  = elimList (\_. R) nil (\hd _ tl. cons hd tl) list;

def map {A B} (fn : A -> B) (list : List A) : List B
  = foldr Nil (\hd tl. Cons (fn hd) tl) list;

def main = #[[], [], []];
